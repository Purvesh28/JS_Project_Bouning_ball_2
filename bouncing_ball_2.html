<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ball Multiplication Escape</title>
<style>
  body {
    margin: 0;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  canvas {
    background: #000;
  }
</style>
</head>
<body>

<canvas id="canvas" width="500" height="500"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const center = {
  x: canvas.width / 2,
  y: canvas.height / 2
};

const circleRadius = 200;
const gapLength = 50;
const gapAngle = gapLength / circleRadius;

// Rotation
let rotationAngle = 0;
const rotationSpeed = 0.02;

// Gravity
const gravity = 0.15;

// Ball storage
const balls = [];

// ðŸŽ¨ Random bright color
function randomColor() {
  return `hsl(${Math.random() * 360}, 80%, 60%)`;
}

function spawnBall(x, y, speed = 3) {
  const angle = Math.random() * Math.PI * 2;
  balls.push({
    x,
    y,
    radius: 8,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    color: randomColor()
  });
}

// Start with one ball
spawnBall(center.x, center.y);

function normalizeAngle(a) {
  return (a + Math.PI * 2) % (Math.PI * 2);
}

function isBallInGap(angle) {
  const start = normalizeAngle(rotationAngle - gapAngle / 2);
  const end   = normalizeAngle(rotationAngle + gapAngle / 2);

  if (start < end) return angle >= start && angle <= end;
  return angle >= start || angle <= end;
}

function drawCircleWithGap() {
  ctx.strokeStyle = "#00ffcc";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(
    center.x,
    center.y,
    circleRadius,
    rotationAngle + gapAngle / 2,
    rotationAngle + Math.PI * 2 - gapAngle / 2
  );
  ctx.stroke();
}

function drawBall(ball) {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = ball.color; // ðŸŽ¨ unique color
  ctx.fill();
}

function updateBalls() {
  for (let i = balls.length - 1; i >= 0; i--) {
    const b = balls[i];

    // ðŸŒ Apply gravity
    b.vy += gravity;

    // Move
    b.x += b.vx;
    b.y += b.vy;

    const dx = b.x - center.x;
    const dy = b.y - center.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = normalizeAngle(Math.atan2(dy, dx));

    if (distance + b.radius >= circleRadius) {

      // ðŸšª Escape through gap
      if (isBallInGap(angle)) {
        balls.splice(i, 1);

        // Spawn 2 new balls
        spawnBall(center.x, center.y);
        spawnBall(center.x, center.y);
        continue;
      }

      // Bounce
      const nx = dx / distance;
      const ny = dy / distance;
      const dot = b.vx * nx + b.vy * ny;

      b.vx -= 2 * dot * nx;
      b.vy -= 2 * dot * ny;

      // Slight energy loss
      b.vx *= 0.98;
      b.vy *= 0.98;

      b.x = center.x + nx * (circleRadius - b.radius);
      b.y = center.y + ny * (circleRadius - b.radius);
    }

    // Cleanup escaped balls
    if (b.y - b.radius > canvas.height + 200) {
      balls.splice(i, 1);
    }
  }
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  rotationAngle += rotationSpeed;

  drawCircleWithGap();
  updateBalls();
  balls.forEach(drawBall);

  requestAnimationFrame(animate);
}

animate();
</script>



</body>
</html>
